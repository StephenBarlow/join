<!doctype html>
<script src=/boot.js></script>
<title>Composed Schema Definition Layer</title>

<div id=view>
<main markdown>

<header>
  <h1>Composed Schema Definition Layer</h1>
  <h2>schema elements for describing composed subgraphs</h2>
  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:jake@apollographql.com>Jake Dawkins</a>
          <li><a rel=author href=mailto:trevor@apollographql.com>Trevor Scheer</a>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Introduction: What is CSDL?

```mermaid
#::[Illustration: CSDL composes multiple subgraph schemas.]
graph LR
  s1(astronauts.graphql)-->CSDL
  s2(rockets.graphql)-->CSDL
  s3(robots.graphql)-->CSDL
  style CSDL fill:none,stroke:fuchsia,color:fuchsia;
```

The Composed Schema Definition Layer (CSDL) provides schema elements to describe a GraphQL Schema which is composed from one or more other GraphQL schemas. **Schema elements** comprise any item in a GraphQL schema—types, input types, directives, etc. CSDL defines directives and mandatory input types. 

The CSDL is intended to be a single artifact which can power a graph router. It declares the composed schema and annotates it with directives that allow the router to disassemble input queries and dispatch them to subgraphs.

CSDL restricts the [GraphQL interface description language](https://spec.graphql.org/) in certain ways: type extensions are not permitted, for instance. It also requires the definition of certain types and provides a suite of directives to describe graph topology. In particular, a CSDL can:
- define [subgraphs](#def-subgraph) and bind them to [endpoints](#def-endpoint) (with the required [`composed_Graph`](#composed_Graph) type and [`@composed_endpoint`](#composed_endpoint) directive)
- assign fields to subgraphs (with [`@composed_resolve`](#composed_resolve))
- declare additional data required and provided by subgraph field resolvers (with [`@composed_key`](#composed_key), and [`@composed_resolve`](#composed_resolve))

## How to read this document

This document uses [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) guidance regarding normative terms:

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
> NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
> "OPTIONAL" in this document are to be interpreted as described in
> RFC 2119.

### What this document isn't

This document specifies only the structure and semantics of the CSDL. It's expected that the CSDL will be the output of a compilation process which composes subgraph schemas. The mechanicss of that process are not specified normatively here; a suggestion is provided in [Appendix: Basic Composition Algorithm](#appendix-suggested-composition-algorithm). Conforming implementations may choose any approach they like, so long as the result is conforming CSDL.

## Example: Let's go to the moon

*This section is non-normative.*

We'll refer to this example of a photo library throughout the document:

<view-of
  src=./photos.graphql
  title='Photos library composed schema'
></view-of>

The meaning of the `@composed_` directives is explored the [Directives](#directives) section.

The example composes three schemas:

[auth](./albums.graphql) provides the `User` type and `Query.me`.

<view-of src=auth.graphql
  title='Auth schema'></view-of>

[images](./images.graphql) provides the `Image` type and `URL` scalar.

<view-of src=images.graphql
  title='Images schema'></view-of>

[albums](./albums.graphql) provides the `Album` type and extends `User` and `Image` with album information.

<view-of src=albums.graphql
  title='Albums schema'></view-of>


## Actors

```mermaid
#::[Actors and roles within an example composition pipeline]
flowchart TB
    subgraph A [subgraph A]
      schemaA([schema A])
      endpointA([endpoint A])
    end    
    subgraph B [subgraph B]
      schemaB([schema B])
      endpointB([endpoint B])
    end
    subgraph C [subgraph C]
      schemaC([schema C])
      endpointC([endpoint C])
    end
    subgraph Producer
      Composer
    end
    CSDL([CSDL])
    subgraph Consumer
      Router
    end    
    A-->Composer
    B-->Composer
    C-->Composer
    Composer-->CSDL
    CSDL-->Router
    Router-->published([Published Schema])
    published-->Clients
    Clients-->Router
```

<a name=def-producer></a>
**Producers** generate CSDL. This spec places requirements on csdl producers.

<a name=def-consumer></a>
**Consumers** consume CSDL. This spec places requirements on csdl consumers.

<a name=def-composer></a>
**Composers** or **compilers** are producers which compose subgraph schemas into CSDL. This document places no particular requirements on the composition algorithm, except that it must produce valid csdl.

<a namme=def-router></a>
**Routers** are consumers which serve a composed schema as a GraphQL endpoint.
  - Graph routers differ from standard GraphQL endpoints in that they are not expected to process data or communicate with (non-GraphQL) backend services on their own. Instead, graph routers receive GraphQL requests and service them by performing additional GraphQL requests. This spec provides guidance for implementing routers, but does not require particular implementations of query separation or dispatch.
  - Routers **may**—and typically will—omit CSDL directives and types from the schema they present to clients via introspection

<a name=def-endpoint></a>
**Endpoints** are running servers which can resolve GraphQL queries against a schema. In this version of the spec, endpoints must be URLs, typically http/https URLs.

<a name=def-subgraph></a>
**Subgraphs** are the GraphQL schemas which were composed to form the CSDL. A subgraph has:
  - a name, which must be unique within the CSDL
  - an [endpoint](#endpoint)

This spec does not place any requirements on subgraph schemas. Generally, they may be of any shape. In particular, subgraph schemas do not need to provide a CSDL; neither is it an error for them to do so. Composers **may** place additional requirements on subgraph schemas to aid in composition; composers **should** document any such requirements.

## Structure

A CSDL document must be a valid [GraphQL schema definition language](https://spec.graphql.org/draft/#sec-Type-System) document.

CSDL removes certain SDL features, as described in the [divergence](#divergence-from-graphql-sdl) section. Nevertheless, CSDL consumers **should** be prepared to parse any valid GraphQL SDL. A CSDL document which contains disallowed SDL constructs **should** trigger validation errors after parsing.

CSDL introduces a suite of types and directives. All CSDL-specific types and directives are prefixed with `composed_` as recommended in [the GraphQL specification](https://spec.graphql.org/draft/#note-ca863).

### Using this spec

CSDL documents **must** contain a `schema` declaration with a [`@using` directive](/using/draft/pre-0).

<view-of src=photos.graphql#schema
  title='@using directive declaring a composed schema'
></view-of>

### Forbidden GraphQL Constructs

CSDL documents cannot contain certain [GraphQL type system](https://spec.graphql.org/draft/#sec-Type-System) constructs. Specifically, **extensions are forbidden.** You cannot `extend type` or `extend interface` within a CSDL document. Producers **must** produce documents without extensions.

## Data Model

### Realized types

A type is *realized* wherever a resolver from a particular *subgraph* returns that type. We use the notation `subgraph::Type` to represent `Type` realized by `subgraph` and `subgraph::Type.field` to represent the resolver for `Type.field` within `subgraph`.

```graphql
#::[Query with resolvers and realized types]
query {          # resolver                    | realizes
                 # ----------------------------|--------------
  rockets {      # rockets::Query.rockets     -> rockets::Rocket
    captain {    # rockets::Rocket.astronaut  -> rockets::Astronaut
      name       # astronauts::Astronaut.name -> String
      rocket {   # rockets::Astronaut.rocket  -> rockets::Rocket
        id       # rockets::Rocket.id         -> ID
      }
    }
  }

}
```

These distinctions are immaterial to the client. As far as clients are concerned, all selections on `Rocket` are the same.

This illusion is maintained by the router, which must break incoming queries into subqueries. In the example above, the path `rockets.captain` is resolved by the `rockets::Rocket.astronaut` resolver, so its selection set is realized as a `rockets::Astronaut`. However, there is no `name` field for `rockets::Astronaut`—instead, the only resolver for `Astronaut.name` is `astronauts::Astronaut.name`. To process this query, the router must "convert" a `rockets::Astronaut` to an `astronauts::Astronaut` via an `_entities` query.

### Free / Bound fields
Free fields can be resolved by any subgraph, bound fields can only be resolved by the subgraph they're bound to.

### Portability
A type is *portable to* a subgraph if it has a `@composed_key` for that subgraph.

Incoming queries cross subgraph boundaries (and thus require "porting") wherever they select a field that is not resolvable by the subgraph of the realized type from which they are selected. In the above example, selecting `rockets.captain.name` crosses such a boundary, since `rockets.captain` has the realized type `rockets::Astronaut` and `captain.name` is only resolvable by `astronauts::Astronaut.name`.

If fields have multiple bound resolvers, routers **should** select the resolver which does not require crossing subgraph boundaries, if possible.

If crossing subgraph boundaries is unavoidable, routers *must* use a [federated _entities query](https://www.apollographql.com/docs/federation/federation-spec/#query_entities) to re-enter the type in the destination subgraph.

## Mandatory Types

Unless otherwise specified, valid composed schemas **must** declare these types.

### `composed_Graph`
A CSDL document **must** define a `composed_Graph` enum. Each enum value defines a subgraph. Each value **must** be annotated with a `@composed_endpoint` directive specifying the endpoint URL for the subgraph.

<view-of src=photos.graphql#composed_Graph
  title='Using composed_Graph to define endpoints'
></view-of>

The `composed_Graph` enum is used as input to csdl directives which link fields and types to subgraphs.

## Provided Types

Valid CSDL documents **must** include the declarations of any CSDL types they use.

### composed_Never

<view-of src=photos.graphql#composed_Never
  title='Declaration of composed_Never'
  class=no-linum
></view-of>

The `composed_Never` type is used to indicate the type of a field which **cannot be resolved**. This is typically due to a composition error. Producers **should** provide more specific error information with a `@composed_error` directive on the relevant field.

<view-of src=photos.graphql#User.favorite
  title='Using <code>composed_Never</code> and <code>@composed_error</code> to mark a field error'
></view-of>

## Scalars

Valid CSDL documents **must** include the declarations of any CSDL scalars they use. Producers **should** include the `@specifiedBy` directive, but it is not mandatory.

### `composed_SelectionSet`
<view-of src=photos.graphql#composed_SelectionSet
  title='Declaration of composed_SelectionSet'
  class=no-linum
></view-of>

A GraphQL selection set represented with the same syntax as defined in [the GraphQL SDL](https://spec.graphql.org/draft/#sec-Selection-Sets).

Note: Unlike the federation `_FieldSet` scalar, a `composed_SelectionSet` must parse as a GraphQL selection set, so the selections must be surrounded by braces.

All legal selection set features are allowed. That includes aliases, field arguments, directives, and inline fragments. Named fragment spreads are syntactically valid, but meaningless, as there is nowhere to define named fragments; future versions of this spec may change this.

### `composed_URL`
<view-of src=photos.graphql#composed_URL
  title='Declaration of composed_URL'
  class=no-linum
></view-of>

A [URL](https://www.w3.org/Addressing/URL/url-spec.html). Used by `@composed_endpoint`.

## Directives

Valid CSDL documents **must** include the declarations of any CSDL directives they use.

### `@composed_key`
<view-of src=photos.graphql#@composed_key
  title='Declaration of composed_key'
  class=no-linum
></view-of>


Define an entity key for this type within a subgraph.

The `@composed_key` directive tells consumers what subset of fields are necessary to identify this type of entity to a particular subgraph. It provides a way for csdl consumers to "switch graphs" when planning a query. For example:

```graphql
#::[A query which requires porting the `Astronaut` type between subgraphs]
query {          # resolver                    | realizes
                 # ----------------------------|--------------
  rockets {      # rockets::Query.rockets     -> rockets::Rocket
    captain {    # rockets::Rocket.astronaut  -> rockets::Astronaut
      name       # astronauts::Astronaut.name -> String
      rocket {   # rockets::Astronaut.rocket  -> rockets::Rocket
        id       # rockets::Rocket.id         -> ID
      }
    }
  }
  
}
```

`Astronaut.name` is provided by the `astronauts` subgraph. But the `captain` field is provided by the `rockets` subgraph.

The fields specified in `repr` will be passed to the subgraph's `Query._entities(representations:)` as an item within the `representations` list.

Multiple `@composed_key`s can be provided for different graphs, or for the same graph.

```graphql
#::[Using `@composed_key` to specify subgraph keys]
type Astronaut
  @composed_key(graph: ASTRONAUTS, repr: "{ id }")
  @composed_key(graph: ROCKETS, repr: "{ id }")
{ ... }
```

### `@composed_endpoint`

```graphql
#::[`@composed_endpoint` declaration]
directive @composed_endpoint(url: composed_URL) on ENUM_VALUE
```

Bind an endpoint URL to a subgraph. This directive is only valid on enum values within the required `composed_Graph` enum type.

```graphql
#::[Using `@composed_endpoint` to specify subgraph endpoints]
enum composed_Graph {
  ROCKETS @composed_endpoint(url: "https://rockets.example.com"),
  ASTRONAUTS @composed_endpoint(url: "https://astronauts.example.com"),
}
```

### `@composed_resolve`

```graphql
#::[`@composed_resolve` declaration]
directive @composed_resolve(
  graph: composed_Graph!,
  requires: composed_SelectionSet,
  provides: composed_SelectionSet) on FIELD_DEFINITION
```

Bind a subgraph resolver to this field.

Any field definitions without a `@composed_resolve` directive are *free*. That is, the CSDL asserts they can be resolved by any subgraph in which the parent type can be found. Specifying `@composed_resolve` binds a field to resolve in exactly one subgraph. Unless it is a root type, the enclosing type **must** be [portable](#portability) to the specified subgraph (it must have `@composed_key`s specified for that graph).

```graphql
#::[Using `@composed_resolve` to specify subgraph resolvers]
type Astronaut
  @composed_key(graph: ASTRONAUTS, fields: "{ id }")
  @composed_key(graph: ROCKETS, fields: "{ id }")
{
  id: String!     @composed_resolve(graph: ASTRONAUTS)
  name: String!   @composed_resolve(graph: ASTRONAUTS)
  tripId: String! @composed_resolve(graph: ASTRONAUTS)
  rocket: Rocket! @composed_resolve(graph: ASTRONAUTS)
}

type Rocket 
  @composed_key(fields: "{ id }", graph: ASTRONAUTS)
  @composed_key(fields: "{ id }", graph: ROCKETS)
{
  id: String!           @composed_resolve(graph: ROCKETS)
  name: String!         @composed_resolve(graph: ROCKETS)
  astronaut: Astronaut! @composed_resolve(graph: ASTRONAUTS)
  captain: Astronaut    @composed_resolve(graph: ASTRONAUTS,
                                    provides: "{ tripId }")
}
```

Fields on root types must always be bound to a subgraph:

```graphql
#::[`@composed_resolve` on root type fields]
type Query {
  rockets: [Rocket]!       @composed_resolve(graph: ROCKETS)
  astronauts: [Astronaut]! @composed_resolve(graph: ASTRONAUTS)
}
```

### `@composed_error`

```graphql
#::[`@composed_error` declaration]
directive @composed_error(
  graphs: [composed_Graph!],
  message: String)
    on OBJECT
     | INTERFACE
     | UNION
     | FIELD_DEFINITION
```

`@composed_error` flags errors that occurred during composition. It's useful for instances where a composer encounters errors but still wants to produce output. It may be used in conjunction with the [`composed_Never`](#composed_never) type to indicate that a field cannot be resolved, along with the reason it cannot be resolved.

```graphql
#::[Using `composed_Never` and `@composed_error` to mark a field error]
type SomeType {
  someField: composed_Never
    @composed_error(
      graphs: [ROCKETS, ASTRONAUTS],
      message: "someField defined with conflicting types")
}
```

## Validations

### validate all fields resolvable
### validate no extensions
### validate csdl version
### validate all fields resolvable

## Appendix: Suggested Composition Algorithm

TK
</main>
</div>