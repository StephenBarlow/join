<!doctype html>
<script src=/boot.js></script>
<title>The @join Directive</title>

<div id=view>
<main markdown>

<header>
  <h1 markdown>the `@join` directive</h1>
  <h2>for defining schemas which join multiple subgraphs</h2>
  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:jake@apollographql.com>Jake Dawkins</a>
          <li><a rel=author href=mailto:trevor@apollographql.com>Trevor Scheer</a>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Introduction

*This section is non-normative.*

```mermaid
#::[Schema joining multiple subgraphs]
graph LR
  s1(auth.graphql)-->core(joined schema: photos.graphql)
  s2(images.graphql)-->core
  s3(albums.graphql)-->core
  style core fill:none,stroke:fuchsia,color:fuchsia;
```

This document defines the [`@join` directive](#join-directive-forms) and [associated types](#associated-types) to describe [core schemas](/core/drafts/pre-0) which **join** multiple **subgraph** schemas into a single **supergraph**.

This specification provides machinery to:
- define [subgraphs](#def-subgraph) with the required [`join__Graph`](#join__Graph) enum
- assign fields to subgraphs
- declare additional data required and provided by subgraph field resolvers

Core schemas using the `@join` directive are referred to as **join schemas** within this document.

## How to read this document

This document uses [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) guidance regarding normative terms:

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
> NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
> "OPTIONAL" in this document are to be interpreted as described in
> RFC 2119.

### What this document isn't

This document specifies only the structure and semantics of join schemas. It's expected that the join schemas will be the output of a compilation process which composes subgraph schemas. The mechanics of that process are not specified normatively here; a suggestion is provided in [Appendix: Basic Composition Algorithm](#appendix-suggested-composition-algorithm). Conforming implementations may choose any approach they like, so long as the result conforms to the requirements of this document.

## Example: Photo Library

*This section is non-normative.*

We'll refer to this example of a photo library throughout the document:

<view-of
  src=./photos.graphql
  title='Photos library composed schema'
></view-of>

The meaning of the `@join` directives is explored in the [Directives](#directives) section.

The example represents **one way** to compose three input schemas, based on [federated composition](https://www.apollographql.com/docs/federation/federation-spec/). These schemas are provided for purposes of illustration only. This spec places no normative requirements on composer input. It does not require that subgraphs use federated composition directives, and it does not place any requirements on *how* the composer builds a join schema, except to say that the resulting schema must be a valid join schema document.

[auth](./albums.graphql) provides the `User` type and `Query.me`.

<view-of src=auth.graphql
  title='Auth schema'></view-of>

[images](./images.graphql) provides the `Image` type and `URL` scalar.

<view-of src=images.graphql
  title='Images schema'></view-of>

[albums](./albums.graphql) provides the `Album` type and extends `User` and `Image` with album information.

<view-of src=albums.graphql
  title='Albums schema'></view-of>


## Actors

```mermaid
#::[Actors and roles within an example composition pipeline]
flowchart TB
    subgraph A [subgraph A]
      schemaA([schema A])
      endpointA([endpoint A])
    end    
    subgraph B [subgraph B]
      schemaB([schema B])
      endpointB([endpoint B])
    end
    subgraph C [subgraph C]
      schemaC([schema C])
      endpointC([endpoint C])
    end
    subgraph "Producer ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀"
      Composer
    end
    joinSchema([Join Schema])
    subgraph "Consumer ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀"
      Router
    end    
    A-->Composer
    B-->Composer
    C-->Composer
    Composer-->joinSchema
    joinSchema-->Router
    Router-->published([Published Schema])
    published-->Clients
    Clients-->Router
```

<a name=def-producer></a>
**Producers** generate join schemas. This spec places requirements on join schema producers.

<a name=def-consumer></a>
**Consumers** consume join schemas. This spec places requirements on join schema consumers.

<a name=def-composer></a>
**Composers** or **compilers** are producers which compose subgraph schemas into a join schema. This document places no particular requirements on the composition algorithm, except that it must produce valid join schemas.

<a namme=def-router></a>
**Routers** are consumers which serve a composed schema as a GraphQL endpoint. *This definition is non-normative.*
  - Graph routers differ from standard GraphQL endpoints in that they are not expected to process data or communicate with (non-GraphQL) backend services on their own. Instead, graph routers receive GraphQL requests and service them by performing additional GraphQL requests. This spec provides guidance for implementing routers, but does not require particular implementations of query separation or dispatch, nor does it attempt to normatively separate routers from other join schema consumers.
  - Routers will often join schema elements from the schema they present to clients via introspection (`join__Graph`, for example, will typically be omitted)

<a name=def-endpoint></a>
**Endpoints** are running servers which can resolve GraphQL queries against a schema. In this version of the spec, endpoints must be URLs, typically http/https URLs.

<a name=def-subgraph></a>
**Subgraphs** are the GraphQL schemas which were composed to form the join schema. They are declared as values on the special `join__Graph` enum.

This spec does not place any requirements on subgraph schemas. Generally, they may be of any shape. In particular, subgraph schemas do not need to be join schemas or to follow this spec in any way; neither is it an error for them to do so. Composers **may** place additional requirements on subgraph schemas to aid in composition; composers **should** document any such requirements.

## Structure

Schemas using `@join` **must** be valid [core schema documents](/core/draft/pre-0) with `@core(using:)` directives referencing this specification along with any transitively referenced specifications.

<view-of src=photos.graphql#schema
  title='@using directive declaring a composed schema'
></view-of>

## Associated Types

### `enum join__Graph`
Documents **must** define a `join__Graph` enum. Each enum value defines a subgraph.

<view-of src=photos.graphql#join__Graph
  title='Using join__Graph to define endpoints'
></view-of>

The `join__Graph` enum is used as input to `@join` directives which link fields and types to subgraphs.

## Scalars

Documents **must** include definitions of any scalars they use. Producers **should** include the `@specifiedBy` directive, but it is not mandatory.

### join__Never

<view-of src=photos.graphql#join__Never
  title='Definition of join__Never'
  class=no-linum
></view-of>

The `join__Never` scalar is used to indicate the type of a field which **cannot be resolved**. This is typically due to a composition error. Producers **should** provide more specific error information with a `@error` directive on the relevant field.

<view-of src=photos.graphql#User.favorite
  title='Using <code>join__Never</code> and <code>@error</code> to mark a field error'
></view-of>

## `@join` directive forms

### `@join(graph: join__Graph!, key: ref__Fragment!) repeatable on OBJECT`

Join a type to a subgraph with the provided entity key.

Keys will be passed as `representations` within a [portal query](#portal-query) to [port](#portability) a selection set between subgraphs.

<view-of src=photos.graphql#local__Image_url
  title='Using <code>@join(graph:,key:)</code> to specify subgraph keys'
></view-of>

Multiple `@join`s can be specified for different subgraphs. It is an error to `@join` an object against the same subgraph multiple times.

### `@join(graph: join__Graph!, requires: ref__Fragment!, provides: ref__Fragment!) on FIELD_DEFINITION`

Join a field with a particular subgraph.

The parent type **MUST** be `@join`ed with 

Any field definitions without a `@join` directive are assumed to be resolvable in any subgraph which `@join`s the parent type.

<view-of src=photos.graphql#User...Image
  title='Using <code>@join</code> to join fields to subgraphs'
  highlight='line => line.includes("@join")'></view-of>

Fields on root types must always be bound to a subgraph:

<view-of src=photos.graphql#Query
  title='<code>@join</code> on root fields'
  highlight='line => line.includes("@join")'></view-of>


## Data Model

```mermaid
#::[The router separates an incoming query into one or more subgraph queries]
graph LR
  incoming(Incoming Query)-->router(Router)
  router-->o1(Outbound Query 1)-->s1(subgraph A)
  router-->o2(Outbound Query 2)-->s2(subgraph B)
  router-->o3(Outbound Query 3)-->s3(subgraph C)
```

### Selection set realization

The role of the router is to break apart an incoming query against the published schema into outbound queries against subgraph schemas.

A *realized selection set* is a selection within an inbound query, with particular type bounds, which will be issued against a particular subgraph. We denote the realized type of this selection set as `subgraph::(Type Bounds)`. Within this section, we use the special subgraph name `self` to refer to the exported composed schema.

Within a realized selection set, the router can only query fields known to the realized subgraph and valid within the type bounds. As usual with GraphQL execution, a selection on more specific bounds can be acquired by emitting an inline fragment (`...on Subtype`). Porting to a different subgraph—to acquire bounds specific to that subgraph, including fields bound to that subgraph—requires a [portal query](#portal-query).

```graphql
#::[Query with resolvers and realized selection sets]
               # resolver              | realizes
               # ---------------------------------------               
query {        # (root)                -> self::Query
    albums {   # albums::Query.albums  -> albums::Album
      user {   # albums::Album.user    -> albums::User
        name   # auth::User.name       -> String
      }
    }
  }
}
```

This query requires one portal: `name` is available on `self::User` but not on `albums::User`. Instead, it is provided only by `auth::User`. Since `name` is selected within an `albums::User`, the router must use a [portal](#portal-query) to acquire a selection on `auth::User` and resolve the field.

### Free / Bound fields
Free fields can be resolved by any subgraph which can realize a selection on the parent type. Bound fields can only be resolved by the subgraph they're bound to, which may require [porting](#portability) the selection set between graphs.

### Portability
A type is *portable to* a subgraph if it has a key defined for that subgraph.

```graphql
#::[A query crossing subgraph boundaries]
query {
  me {
    albums {
      user {
        name
      }
    }
  }
}
```

Incoming queries cross subgraph boundaries require "porting" wherever they select a field that is not resolvable by the subgraph of the realized type from which they are selected. In the above example, selecting `me.albums.user.name` crosses such a boundary, since `albums.user` is a selection on `albums::User` and `user.name` is only resolvable by `auth::User.name`.

To resolve this query, `albums::User` must be *portable* to `auth::User`. That is, given a selection on `albums::User`, there must be some way to arrive at a selection on `auth::User`.

If fields have multiple bound resolvers, routers **should** select the resolver which does not require crossing subgraph boundaries, if possible.

If crossing subgraph boundaries is unavoidable, routers *must* use a [portal query](#portal-query) to re-enter the type in the destination subgraph.

### Portal query
In order to acquire a selection set on a entity within a subgraph, routers may issue a portal query to the subgraph:

```graphql
#::[Portal query]
query {
  _entities(representations: $representations) {
    # ...selections...
  }
}
```

`representations` **must** be a list of input objects, each of which consist of the `__typename` of the object type or interface along with the result of fetching one that subgraph's `key` fragment for the type.

```graphql
#::[Portal query with representations]
query {
  _entities(representations: [
    { __typename: "Image", url: "http://example.com/1.png"},
    { __typename: "Image", url: "http://example.com/2.png"},
  ]) {
    # ...selection on Image...
  }
}
```

The `_entities` resolver need not be explicitly defined in the subgraph schema. If it is defined, its specified types are ignored—it is assumed that the resolver is capable of resolving objects and interfaces from any key specified within the join schema.

## Validations
### validate all fields resolvable
### validate no extensions
### validate version
### validate all fields resolvable

## Appendix: Suggested Composition Algorithm

TK
</main>
</div>