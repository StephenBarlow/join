<!doctype html>
<script src=/boot.js></script>
<title>Composing Schemas</title>

<div id=view>
<main markdown>

<header>
  <h1>Composing Schemas</h1>
  <h2>schema elements for describing compositions of subgraphs</h2>
  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:jake@apollographql.com>Jake Dawkins</a>
          <li><a rel=author href=mailto:trevor@apollographql.com>Trevor Scheer</a>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Introduction

*This section is non-normative.*

```mermaid
#::[Schema composed from multiple subgraphs.]
graph LR
  s1(auth.graphql)-->CSDL(Composed Schema: photos.graphql)
  s2(images.graphql)-->CSDL
  s3(albums.graphql)-->CSDL
  style CSDL fill:none,stroke:fuchsia,color:fuchsia;
```

This document lays out **schema elements** to describe [GraphQL schemas](https://spec.graphql.org/) which are **`compose`d** from one or more other GraphQL schemas. (**Schema elements** comprise any item in a GraphQL schema—types, input types, directives, etc.)

A `compose`d schema is intended to be a single artifact which can power a graph router. It declares the composed schema and annotates it with directives that allow the router to disassemble input queries and dispatch them to subgraphs.

```mermaid
#::[Composed schemas are generally machine-generated]
graph LR
  s1(auth.graphql)-->compiler(Compiler)
  s2(images.graphql)-->compiler
  s3(albums.graphql)-->compiler
  compiler-->CSDL(Composed Schema: photos.graphql)
  style compiler fill:none,stroke:fuchsia,color:fuchsia;
```

`Compose`d schemas are generally assumed to be machine-generated from source schemas. Design decisions lean towards making them easy to consume—explicitness is favored over implicitness, even where this may become repetitive.

Within composed schemas, one can:
- define [subgraphs](#def-subgraph) and bind them to [endpoints](#def-endpoint) (with the required [`compose_Graph`](#compose_Graph) type and [`@compose_outbound`](#compose_outbound) directive)
- assign fields to subgraphs (with [`@compose_resolve`](#compose_resolve))
- declare additional data required and provided by subgraph field resolvers (with [`@compose_key`](#compose_key), and [`@compose_resolve`](#compose_resolve))

## How to read this document

This document uses [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) guidance regarding normative terms:

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
> NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
> "OPTIONAL" in this document are to be interpreted as described in
> RFC 2119.

### What this document isn't

This document specifies only the structure and semantics of `compose`d schemas. It's expected that the `compose`d schema will be the output of a compilation process which composes subgraph schemas. The mechanicss of that process are not specified normatively here; a suggestion is provided in [Appendix: Basic Composition Algorithm](#appendix-suggested-composition-algorithm). Conforming implementations may choose any approach they like, so long as the result conforms to the requirements of this document.

## Example: Photo Library

*This section is non-normative.*

We'll refer to this example of a photo library throughout the document:

<view-of
  src=./photos.graphql
  title='Photos library composed schema'
></view-of>

The meaning of the `@compose_` directives is explored the [Directives](#directives) section.

The example composes three schemas:

[auth](./albums.graphql) provides the `User` type and `Query.me`.

<view-of src=auth.graphql
  title='Auth schema'></view-of>

[images](./images.graphql) provides the `Image` type and `URL` scalar.

<view-of src=images.graphql
  title='Images schema'></view-of>

[albums](./albums.graphql) provides the `Album` type and extends `User` and `Image` with album information.

<view-of src=albums.graphql
  title='Albums schema'></view-of>


## Actors

```mermaid
#::[Actors and roles within an example composition pipeline]
flowchart TB
    subgraph A [subgraph A]
      schemaA([schema A])
      endpointA([endpoint A])
    end    
    subgraph B [subgraph B]
      schemaB([schema B])
      endpointB([endpoint B])
    end
    subgraph C [subgraph C]
      schemaC([schema C])
      endpointC([endpoint C])
    end
    subgraph Producer
      Composer
    end
    CSDL([CSDL])
    subgraph Consumer
      Router
    end    
    A-->Composer
    B-->Composer
    C-->Composer
    Composer-->CSDL
    CSDL-->Router
    Router-->published([Published Schema])
    published-->Clients
    Clients-->Router
```

<a name=def-producer></a>
**Producers** generate `compose`d schemas. This spec places requirements on `compose`d schema producers.

<a name=def-consumer></a>
**Consumers** consume `compose`d schemas. This spec places requirements on `compose`d schema consumers.

<a name=def-composer></a>
**Composers** or **compilers** are producers which compose subgraph schemas into a `compose`d schema. This document places no particular requirements on the composition algorithm, except that it must produce valid `compose`d schemas.

<a namme=def-router></a>
**Routers** are consumers which serve a composed schema as a GraphQL endpoint.
  - Graph routers differ from standard GraphQL endpoints in that they are not expected to process data or communicate with (non-GraphQL) backend services on their own. Instead, graph routers receive GraphQL requests and service them by performing additional GraphQL requests. This spec provides guidance for implementing routers, but does not require particular implementations of query separation or dispatch.
  - Routers **may**—and typically will—omit `compose`d schema elements from the schema they present to clients via introspection (`compose_Graph`, for example, **may** and often will be omitted)

<a name=def-endpoint></a>
**Endpoints** are running servers which can resolve GraphQL queries against a schema. In this version of the spec, endpoints must be URLs, typically http/https URLs.

<a name=def-subgraph></a>
**Subgraphs** are the GraphQL schemas which were composed to form the `compose`d schema. They are declared as values on the special `compose_Graph` enum. Link transport data is provided with the `@compose_link` directive.

This spec does not place any requirements on subgraph schemas. Generally, they may be of any shape. In particular, subgraph schemas do not need to be `compose`d or follow this spec in any way; neither is it an error for them to do so. Composers **may** place additional requirements on subgraph schemas to aid in composition; composers **should** document any such requirements.

## Structure

A `compose`d schema must be a valid [GraphQL schema definition language](https://spec.graphql.org/draft/#sec-Type-System) document.

Certain GraphQL features are restricted within `compose`d schemas. In particular, **extensions are forbidden**. Producers **must** not generate `compose`d schemas which contain type or interface extensions. Nevertheless, consumers **should** be prepared to parse any valid GraphQL SDL. A `compose`d schema document which contains type extensions or any other disallowed constructs **should** trigger validation errors after parsing.

This spec introduces a suite of types and directives. All schema elements introduced in this spec carry a `compose_` prefix, as recommended in [the GraphQL specification](https://spec.graphql.org/draft/#note-ca863).

### Declare use of this spec

`Compose`d schemas **must** contain a `schema` declaration with a [`@using` directive](/using/draft/pre-0).

<view-of src=photos.graphql#schema
  title='@using directive declaring a composed schema'
></view-of>

### `Compose`d schemas must not contain `TypeSystemExtension`s

`Compose`d schemas cannot contain extensions—you cannot `extend type` or `extend interface` within a `compose`d schema. Producers **must** generate documents which contain only GraphQL [`TypeSystemDefinition`s](http://spec.graphql.org/draft/#sec-Type-System). Consumers **should** ignore any `TypeSystemExtension`s or other meaningless definitions within `compose`d schemas.

## Enums

`compose`d schemas **must** definitions of any enums they use.

### `compose_Graph`
A CSDL document **must** define a `compose_Graph` enum. Each enum value defines a subgraph. Each value **must** be annotated with a `@compose_link` directive specifying how to connect to the subgraph.

<view-of src=photos.graphql#compose_Graph
  title='Using compose_Graph to define endpoints'
></view-of>

The `compose_Graph` enum is used as input to `compose`d schema directives which link fields and types to subgraphs.

## Input Object Types

`compose`d schemas **must** include definitions of any `input`s they use.

`input`s do not have to be specified exactly as they are in this spec—they need only be *compatible*. In particular, a `compose`d schema may:
  - **Change nullable fields to non-nullable,** indicating that this `compose`d schema adheres to a stricter contract than required.
  - **Omit nullable fields** which are never referenced
  - **Introduce new fields.** Fields added to an `input` **must** be prefixed with `someVendorPrefix_`. For example, a composed schema might introduce a custom field on `compose_OutboundLink` to hold internal service discovery information:

```graphql
#::[Using a custom field in `compose_OutboundLink`]
input compose_OutboundLink {
  exampleOrg_gslb: exampleOrg_OutboundGSLB
}

input exampleOrg_OutboundGSLB {
  service: String
  protocolVersion: Int = 2
}

enum compose_Graph {
  AUTH @compose_link(to: {
    exampleOrg_gslb: {
      service: "gaia/auth-gql-prod", protocol_version: 1
    }
  }),
  MAPS @compose_link(to: {
    exampleOrg_gslb: { service: "geo/prod" }
  })
}
```

### compose_OutboundLink
<view-of src=photos.graphql#compose_OutboundLink
  title='Definition of compose_OutboundLink'
  class=no-linum></view-of>

Provides information about an **outbound link**—a connection to a subgraph across which operations can be executed.

### compose_OutboundLinkHTTP
<view-of src=photos.graphql#compose_OutboundLinkHTTP
  title='Definition of compose_OutboundLinkHTTP'
  class=no-linum></view-of>

Provides HTTP-specific configuration for outbound links. **TK: Currently, this is just a URL, but this is the place where we could do a lot more: headers, etc. ~ak**


## Scalars

`compose`d schemas **must** include definitions of any scalars they use. Producers **should** include the `@specifiedBy` directive, but it is not mandatory.

### `compose_SelectionSet`

<view-of src=photos.graphql#compose_SelectionSet
  title='Definition of compose_SelectionSet'
  class=no-linum
></view-of>

A GraphQL selection set represented with the same syntax as defined in [the GraphQL SDL](https://spec.graphql.org/draft/#sec-Selection-Sets).

Note: Unlike the federation `_FieldSet` scalar, a `compose_SelectionSet` must parse as a GraphQL selection set, so the selections must be surrounded by braces.

All legal selection set features are allowed. That includes aliases, field arguments, directives, and inline fragments. Named fragment spreads are syntactically valid, but meaningless, as there is nowhere to define named fragments; future versions of this spec may change this.

### `compose_URL`

<view-of src=photos.graphql#compose_URL
  title='Definition of compose_URL'
  class=no-linum
></view-of>

A [URL](https://www.w3.org/Addressing/URL/url-spec.html). Used by [`@compose_outbound`](#compose_outbound).

### compose_Never

<view-of src=photos.graphql#compose_Never
  title='Definition of compose_Never'
  class=no-linum
></view-of>

The `compose_Never` scalar is used to indicate the type of a field which **cannot be resolved**. This is typically due to a composition error. Producers **should** provide more specific error information with a `@compose_error` directive on the relevant field.

<view-of src=photos.graphql#User.favorite
  title='Using <code>compose_Never</code> and <code>@compose_error</code> to mark a field error'
></view-of>

## Directives

`compose`d schema **must** include the definitions of all directives they use. Directives from this spec **must** be defined exactly as they are specified here. (This ensures that `compose`d schemas pass standard validations, even if those validators do not know of this spec.)

### `@compose_key`
<view-of src=photos.graphql#@compose_key
  title='Definition of compose_key'
  class=no-linum
></view-of>

Define an entity key for this type within a subgraph.

The `@compose_key` directive tells consumers what subset of fields are necessary to identify this type of entity to a particular subgraph. It provides a way for consumers to "switch graphs" when planning a query. For example:

```graphql
#::[A query which requires porting the `Astronaut` type between subgraphs]
query {          # resolver                    | realizes
                 # ----------------------------|--------------
  rockets {      # rockets::Query.rockets     -> rockets::Rocket
    captain {    # rockets::Rocket.astronaut  -> rockets::Astronaut
      name       # astronauts::Astronaut.name -> String
      rocket {   # rockets::Astronaut.rocket  -> rockets::Rocket
        id       # rockets::Rocket.id         -> ID
      }
    }
  }
  
}
```

`Astronaut.name` is provided by the `astronauts` subgraph. But the `captain` field is provided by the `rockets` subgraph.

The fields specified in `repr` will be passed to the subgraph's `Query._entities(representations:)` as an item within the `representations` list.

Multiple `@compose_key`s can be provided for different graphs, or for the same graph.

<view-of src=photos.graphql#Image
  title='Using <code>@compose_key</code> to specify subgraph keys'
  highlight='line => line.includes("@compose_key")'
></view-of>

### `@compose_link`

<view-of src=photos.graphql#@compose_link...compose_OutboundLinkHTTP
  title='Definition of compose_link and related inputs'
  class=no-linum
></view-of>

`@compose_link` declares links to other graphs defined within `compose_Graph`. For example, `@compose_link` is where you specify HTTP endpoint URLs for subgraph services.

<view-of src=photos.graphql#compose_Graph
  title='Using <code>@compose_link</code> to specify subgraph connections'
></view-of>

This directive is only valid on enum values within the required `compose_Graph` enum type.

### `@compose_resolve`

<view-of src=photos.graphql#@compose_resolve
  title='Definition of <code>@compose_resolve</code>'
  class=no-linum></view-of>

Bind a subgraph resolver to this field.

Any field definitions without a `@compose_resolve` directive are *free*. That is, the `compose`d schema asserts they can be resolved by any subgraph in which the parent type can be found. Specifying `@compose_resolve` binds a field to resolve in exactly one subgraph. Unless it is a root type, the enclosing type **must** be [portable](#portability) to the specified subgraph (it must have `@compose_key`s specified for that graph).

<view-of src=photos.graphql#User...Image
  title='Using <code>@compose_resolve</code> to bind subgraph resolvers'
  highlight='line => line.includes("@compose_resolve")'></view-of>

Fields on root types must always be bound to a subgraph:

<view-of src=photos.graphql#Query
  title='<code>@compose_resolve</code> on root fields'
  highlight='line => line.includes("@compose_resolve")'></view-of>

### `@compose_error`

<view-of src=photos.graphql#@compose_error
  title='<code>@compose_error</code> declaration' class=no-linum></view-of>

`@compose_error` flags errors that occurred during composition. It's useful for instances where a composer encounters errors but still wants to produce output. It may be used in conjunction with the [`compose_Never`](#compose_never) type to indicate that a field cannot be resolved, along with the reason it cannot be resolved.


<view-of src=photos.graphql#User.favorite
  title='Using <code>compose_Never</code> and <code>@compose_error</code> declaration'></view-of>

## Data Model

### Realized types

A type is *realized* wherever a resolver from a particular *subgraph* returns that type. We use the notation `subgraph::Type` to represent `Type` realized by `subgraph` and `subgraph::Type.field` to represent the resolver for `Type.field` within `subgraph`.

```graphql
#::[Query with resolvers and realized types]
query {          # resolver                    | realizes
                  # ----------------------------|--------------
  rockets {      # rockets::Query.rockets     -> rockets::Rocket
    captain {    # rockets::Rocket.astronaut  -> rockets::Astronaut
      name       # astronauts::Astronaut.name -> String
      rocket {   # rockets::Astronaut.rocket  -> rockets::Rocket
        id       # rockets::Rocket.id         -> ID
      }
    }
  }

}
```

These distinctions are immaterial to the client. As far as clients are concerned, all selections on `Rocket` are the same.

This illusion is maintained by the router, which must break incoming queries into subqueries. In the example above, the path `rockets.captain` is resolved by the `rockets::Rocket.astronaut` resolver, so its selection set is realized as a `rockets::Astronaut`. However, there is no `name` field for `rockets::Astronaut`—instead, the only resolver for `Astronaut.name` is `astronauts::Astronaut.name`. To process this query, the router must [port](#portability) a `rockets::Astronaut` to an `astronauts::Astronaut` via an `_entities` query.

### Free / Bound fields
Free fields can be resolved by any subgraph, bound fields can only be resolved by the subgraph they're bound to.

### Portability
A type is *portable to* a subgraph if it has a `@compose_key` for that subgraph.

Incoming queries cross subgraph boundaries (and thus require "porting") wherever they select a field that is not resolvable by the subgraph of the realized type from which they are selected. In the above example, selecting `rockets.captain.name` crosses such a boundary, since `rockets.captain` has the realized type `rockets::Astronaut` and `captain.name` is only resolvable by `astronauts::Astronaut.name`.

If fields have multiple bound resolvers, routers **should** select the resolver which does not require crossing subgraph boundaries, if possible.

If crossing subgraph boundaries is unavoidable, routers *must* use a [federated _entities query](https://www.apollographql.com/docs/federation/federation-spec/#query_entities) to re-enter the type in the destination subgraph.
  

## Validations
### validate all fields resolvable
### validate no extensions
### validate version
### validate all fields resolvable

## Appendix: Suggested Composition Algorithm

TK
</main>
</div>